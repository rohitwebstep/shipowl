{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Webstep2/shipping-owl/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"../../prisma/prisma/generated/client\"; // Adjust the import path as necessary\r\n\r\nconst prisma = new PrismaClient();\r\n\r\nasync function connectToDatabase() {\r\n    try {\r\n        // Attempt to connect to the database\r\n        await prisma.$connect();\r\n        console.log(\"Database connection established successfully.\");\r\n    } catch (error) {\r\n        // If connection fails, log the error\r\n        console.error(\"Database connection failed:\", error);\r\n        // Avoid using process.exit in Edge Runtime\r\n        // Instead, you can throw an error to be handled by the calling code\r\n        throw new Error(\"Database connection failed\");\r\n    }\r\n}\r\n\r\nconnectToDatabase().catch((error) => {\r\n    // Handle any unhandled promise rejections here, if necessary\r\n    console.error(error);\r\n    // You can choose to return a response or perform other actions instead of exiting\r\n});\r\n\r\nexport default prisma;\r\n"],"names":[],"mappings":";;;;;;;;;AAEA,MAAM,SAAS,IAAI;AAEnB,eAAe;IACX,IAAI;QACA,qCAAqC;QACrC,MAAM,OAAO,QAAQ;QACrB,QAAQ,GAAG,CAAC;IAChB,EAAE,OAAO,OAAO;QACZ,qCAAqC;QACrC,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,2CAA2C;QAC3C,oEAAoE;QACpE,MAAM,IAAI,MAAM;IACpB;AACJ;AAEA,oBAAoB,KAAK,CAAC,CAAC;IACvB,6DAA6D;IAC7D,QAAQ,KAAK,CAAC;AACd,kFAAkF;AACtF;uCAEe","debugId":null}},
    {"offset": {"line": 127, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Webstep2/shipping-owl/src/utils/auth/authUtils.ts"],"sourcesContent":["import jwt from 'jsonwebtoken';\r\nimport { jwtVerify } from 'jose';\r\nimport prisma from \"@/lib/prisma\";\r\n\r\nconst SECRET_KEY = process.env.JWT_SECRET || '3792e68ef011e0f236a60627ddf304e1bb64d76d5e4dbebca4579490d3c4e6d8c618456f29aa6f92f8dc3cbd4414362b47d4545ffdc0b9549e43b629c39282bb36b9cff7295fc4269d765d59e4d8a811113b911080878f7647e0329a072afdc06d2ecd658c8e79f2ad04e74dbffc45ed10c850b02afdf10b209989910fadaf7ddbef0bb7d0cff27ed8f4a10d3415420107ddba2d9ac8bcf4f7b3b942b5bbe600d9007f9e88b2451cbfaeaab239677b3ed28eaa860eb40fd5d0e36969b6943a3215d2a9f1125ca06be806f8d73d8ae642c4a29b3a728cf42305e1150e4c1f3ed6e14bd3662531cd14357c6b3f3a57095609811f5e9459307cbe70f9b7a159c8d3';\r\n\r\nexport function generateToken(adminId: number, adminRole: string) {\r\n    console.log(`adminId: ${adminId}, adminRole: ${adminRole}`);\r\n    return jwt.sign({ adminId, adminRole }, SECRET_KEY, { expiresIn: '3h' });\r\n}\r\n\r\nexport function generatePasswordResetToken(adminId: number, adminRole: string) {\r\n    return jwt.sign({ adminId, adminRole }, SECRET_KEY, { expiresIn: '1h' });\r\n}\r\n\r\nexport function generateRegistrationToken(adminId: number, adminRole: string) {\r\n    return jwt.sign({ adminId, adminRole }, SECRET_KEY, { expiresIn: '1h' });\r\n}\r\n\r\nexport async function verifyToken(token: string) {\r\n    try {\r\n        const { payload } = await jwtVerify(token, new TextEncoder().encode(SECRET_KEY));\r\n        return { payload, status: true, message: \"Token is valid\" };\r\n    } catch (error) {\r\n        let message = \"Authentication failed. Please try again.\";\r\n\r\n        if (typeof error === \"object\" && error !== null && \"code\" in error) {\r\n            const err = error as { code: string };\r\n            if (err.code === 'ERR_JWT_EXPIRED') {\r\n                message = \"Session expired. Please log in again.\";\r\n            }\r\n        }\r\n        return { payload: null, status: false, message };\r\n    }\r\n}\r\n\r\n// Check if admin exists in the database\r\nexport async function isUserExist(adminId: number, adminRole: string) {\r\n    try {\r\n        const adminRoleStr = String(adminRole); // Ensure it's a string\r\n        const adminModel = [\"admin\", \"dropshipper\", \"supplier\"].includes(adminRoleStr) ? \"admin\" : \"adminStaff\";\r\n\r\n        // Fetch admin details from database\r\n        let admin\r\n        if (adminModel === \"admin\") {\r\n            admin = await prisma.admin.findUnique({\r\n                where: { id: adminId, role: adminRoleStr },\r\n                select: {\r\n                    id: true,\r\n                    name: true,\r\n                    email: true,\r\n                    password: true,\r\n                    role: true,\r\n                },\r\n            });\r\n        } else {\r\n            admin = await prisma.adminStaff.findUnique({\r\n                where: { id: adminId, role: adminRoleStr },\r\n                select: {\r\n                    id: true,\r\n                    name: true,\r\n                    email: true,\r\n                    password: true, // Hashed password stored in DB\r\n                    role: true,\r\n                    admin: true\r\n                }\r\n            });\r\n        }\r\n\r\n        // If admin doesn't exist, return false with a message\r\n        if (!admin) {\r\n            return { status: false, message: \"User with the provided ID does not exist\" };\r\n        }\r\n\r\n        // Return admin details if found\r\n        return { status: true, admin };\r\n    } catch (error) {\r\n        console.error(\"Error fetching admin by ID:\", error);\r\n        return { status: false, message: \"Internal Server Error\" };\r\n    }\r\n}"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAEtC,SAAS,cAAc,OAAe,EAAE,SAAiB;IAC5D,QAAQ,GAAG,CAAC,CAAC,SAAS,EAAE,QAAQ,aAAa,EAAE,WAAW;IAC1D,OAAO,uIAAA,CAAA,UAAG,CAAC,IAAI,CAAC;QAAE;QAAS;IAAU,GAAG,YAAY;QAAE,WAAW;IAAK;AAC1E;AAEO,SAAS,2BAA2B,OAAe,EAAE,SAAiB;IACzE,OAAO,uIAAA,CAAA,UAAG,CAAC,IAAI,CAAC;QAAE;QAAS;IAAU,GAAG,YAAY;QAAE,WAAW;IAAK;AAC1E;AAEO,SAAS,0BAA0B,OAAe,EAAE,SAAiB;IACxE,OAAO,uIAAA,CAAA,UAAG,CAAC,IAAI,CAAC;QAAE;QAAS;IAAU,GAAG,YAAY;QAAE,WAAW;IAAK;AAC1E;AAEO,eAAe,YAAY,KAAa;IAC3C,IAAI;QACA,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA,GAAA,yJAAA,CAAA,YAAS,AAAD,EAAE,OAAO,IAAI,cAAc,MAAM,CAAC;QACpE,OAAO;YAAE;YAAS,QAAQ;YAAM,SAAS;QAAiB;IAC9D,EAAE,OAAO,OAAO;QACZ,IAAI,UAAU;QAEd,IAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,UAAU,OAAO;YAChE,MAAM,MAAM;YACZ,IAAI,IAAI,IAAI,KAAK,mBAAmB;gBAChC,UAAU;YACd;QACJ;QACA,OAAO;YAAE,SAAS;YAAM,QAAQ;YAAO;QAAQ;IACnD;AACJ;AAGO,eAAe,YAAY,OAAe,EAAE,SAAiB;IAChE,IAAI;QACA,MAAM,eAAe,OAAO,YAAY,uBAAuB;QAC/D,MAAM,aAAa;YAAC;YAAS;YAAe;SAAW,CAAC,QAAQ,CAAC,gBAAgB,UAAU;QAE3F,oCAAoC;QACpC,IAAI;QACJ,IAAI,eAAe,SAAS;YACxB,QAAQ,MAAM,sHAAA,CAAA,UAAM,CAAC,KAAK,CAAC,UAAU,CAAC;gBAClC,OAAO;oBAAE,IAAI;oBAAS,MAAM;gBAAa;gBACzC,QAAQ;oBACJ,IAAI;oBACJ,MAAM;oBACN,OAAO;oBACP,UAAU;oBACV,MAAM;gBACV;YACJ;QACJ,OAAO;YACH,QAAQ,MAAM,sHAAA,CAAA,UAAM,CAAC,UAAU,CAAC,UAAU,CAAC;gBACvC,OAAO;oBAAE,IAAI;oBAAS,MAAM;gBAAa;gBACzC,QAAQ;oBACJ,IAAI;oBACJ,MAAM;oBACN,OAAO;oBACP,UAAU;oBACV,MAAM;oBACN,OAAO;gBACX;YACJ;QACJ;QAEA,sDAAsD;QACtD,IAAI,CAAC,OAAO;YACR,OAAO;gBAAE,QAAQ;gBAAO,SAAS;YAA2C;QAChF;QAEA,gCAAgC;QAChC,OAAO;YAAE,QAAQ;YAAM;QAAM;IACjC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;YAAE,QAAQ;YAAO,SAAS;QAAwB;IAC7D;AACJ","debugId":null}},
    {"offset": {"line": 255, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Webstep2/shipping-owl/src/utils/hashUtils.ts"],"sourcesContent":["import bcrypt from 'bcryptjs';\r\n\r\nexport async function hashPassword(password: string) {\r\n    const salt = await bcrypt.genSalt(10);\r\n    return bcrypt.hash(password, salt);\r\n}\r\n\r\nexport async function comparePassword(password: string, hashedPassword: string) {\r\n    return bcrypt.compare(password, hashedPassword);\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;;AAEO,eAAe,aAAa,QAAgB;IAC/C,MAAM,OAAO,MAAM,mIAAA,CAAA,UAAM,CAAC,OAAO,CAAC;IAClC,OAAO,mIAAA,CAAA,UAAM,CAAC,IAAI,CAAC,UAAU;AACjC;AAEO,eAAe,gBAAgB,QAAgB,EAAE,cAAsB;IAC1E,OAAO,mIAAA,CAAA,UAAM,CAAC,OAAO,CAAC,UAAU;AACpC","debugId":null}},
    {"offset": {"line": 274, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Webstep2/shipping-owl/src/app/models/admin/emailConfig.ts"],"sourcesContent":["import prisma from \"@/lib/prisma\";\r\n\r\n// type PanelType = \"admin\" | \"dropshipper\" | \"supplier\";\r\n\r\n/**\r\n * Retrieves email configurations for a specific panel, module, and action.\r\n *\r\n * @param panel - The target panel (admin, dropshipper, supplier)\r\n * @param module - The related module (e.g., user, order, notification)\r\n * @param action - The triggering action (e.g., welcome, reset_password)\r\n * @param status - The status of the email config (default is true, can be set to false to fetch inactive configs)\r\n * @returns A response object with status and data or an error message\r\n */\r\nexport const getEmailConfig = async (\r\n    panel: string,\r\n    module: string,\r\n    action: string,\r\n    status: boolean = true // Default value is true\r\n) => {\r\n    try {\r\n        console.log(`Fetching email configuration for panel: ${panel}, module: ${module}, action: ${action}, status: ${status}`);\r\n        // Fetching the email configuration from the database based on conditions\r\n        const emailConfig = await prisma.emailConfig.findFirst({\r\n            where: {\r\n                panel,\r\n                module,\r\n                action,\r\n                status\r\n            },\r\n            orderBy: { id: \"desc\" },\r\n        });\r\n\r\n        if (!emailConfig) {\r\n            return { status: false, message: \"Email configuration not found\" };\r\n        }\r\n\r\n        // Mapping the database result to the desired output format\r\n        const config = {\r\n            host: emailConfig.smtp_host,\r\n            port: emailConfig.smtp_port,\r\n            secure: emailConfig.smtp_secure,\r\n            username: emailConfig.smtp_username,\r\n            password: emailConfig.smtp_password,\r\n            from_email: emailConfig.from_email,\r\n            from_name: emailConfig.from_name,\r\n        };\r\n\r\n        return { status: true, emailConfig: config, htmlTemplate: emailConfig.html_template, subject: emailConfig.subject };\r\n    } catch (error) {\r\n        console.error(`Error fetching email configuration for panel \"${panel}\", module \"${module}\", action \"${action}\":`, error);\r\n        return { status: false, message: \"Error fetching email configuration\" };\r\n    }\r\n};\r\n"],"names":[],"mappings":";;;AAAA;;AAaO,MAAM,iBAAiB,OAC1B,OACA,QACA,QACA,SAAkB,KAAK,wBAAwB;AAAzB;IAEtB,IAAI;QACA,QAAQ,GAAG,CAAC,CAAC,wCAAwC,EAAE,MAAM,UAAU,EAAE,OAAO,UAAU,EAAE,OAAO,UAAU,EAAE,QAAQ;QACvH,yEAAyE;QACzE,MAAM,cAAc,MAAM,sHAAA,CAAA,UAAM,CAAC,WAAW,CAAC,SAAS,CAAC;YACnD,OAAO;gBACH;gBACA;gBACA;gBACA;YACJ;YACA,SAAS;gBAAE,IAAI;YAAO;QAC1B;QAEA,IAAI,CAAC,aAAa;YACd,OAAO;gBAAE,QAAQ;gBAAO,SAAS;YAAgC;QACrE;QAEA,2DAA2D;QAC3D,MAAM,SAAS;YACX,MAAM,YAAY,SAAS;YAC3B,MAAM,YAAY,SAAS;YAC3B,QAAQ,YAAY,WAAW;YAC/B,UAAU,YAAY,aAAa;YACnC,UAAU,YAAY,aAAa;YACnC,YAAY,YAAY,UAAU;YAClC,WAAW,YAAY,SAAS;QACpC;QAEA,OAAO;YAAE,QAAQ;YAAM,aAAa;YAAQ,cAAc,YAAY,aAAa;YAAE,SAAS,YAAY,OAAO;QAAC;IACtH,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,CAAC,8CAA8C,EAAE,MAAM,WAAW,EAAE,OAAO,WAAW,EAAE,OAAO,EAAE,CAAC,EAAE;QAClH,OAAO;YAAE,QAAQ;YAAO,SAAS;QAAqC;IAC1E;AACJ","debugId":null}},
    {"offset": {"line": 427, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Webstep2/shipping-owl/src/utils/email/sendEmail.ts"],"sourcesContent":["import nodemailer from \"nodemailer\";\r\n\r\ninterface EmailAddress {\r\n    name: string;\r\n    email: string;\r\n}\r\n\r\ninterface EmailAttachment {\r\n    name: string;\r\n    path: string;\r\n}\r\n\r\ninterface SMTPConfig {\r\n    host: string; // SMTP server hostname\r\n    port: number; // SMTP server port\r\n    secure: boolean; // Use TLS/SSL for connection\r\n    username: string; // SMTP authentication username\r\n    password: string; // SMTP authentication password\r\n    from_email: string; // Sender's email address\r\n    from_name: string; // Sender's name to appear in \"From\" field (e.g., \"Company Name\")\r\n}\r\n\r\ninterface MailData {\r\n    recipient: EmailAddress[];\r\n    cc?: EmailAddress[];\r\n    bcc?: EmailAddress[];\r\n    subject: string;\r\n    htmlBody: string;\r\n    attachments?: EmailAttachment[];\r\n}\r\n\r\ninterface EmailResult {\r\n    status: boolean;\r\n    messageId?: string;\r\n    error?: string;\r\n}\r\n\r\n/**\r\n * Sends a professional HTML email with optional CC, BCC, and attachments.\r\n */\r\nexport async function sendEmail(\r\n    config: SMTPConfig,\r\n    mailData: MailData\r\n): Promise<EmailResult> {\r\n    const { host, port, secure, username, password, from_email, from_name } = config;\r\n    const {\r\n        recipient = [],\r\n        cc = [],\r\n        bcc = [],\r\n        subject,\r\n        htmlBody,\r\n        attachments = [],\r\n    } = mailData;\r\n\r\n    const formatAddressList = (list: EmailAddress[]) =>\r\n        Array.isArray(list) ? list.map(({ name, email }) => `${name} <${email}>`) : [];\r\n\r\n    const formatAttachments = (list: EmailAttachment[]) =>\r\n        list.map(({ name, path }) => ({\r\n            filename: name,\r\n            path: path,\r\n        }));\r\n\r\n    try {\r\n        const transporter = nodemailer.createTransport({\r\n            host,\r\n            port: Number(port),\r\n            secure,\r\n            auth: { user: username, pass: password },\r\n        });\r\n\r\n        const mailOptions = {\r\n            from: `${from_name} <${from_email}>`,\r\n            to: formatAddressList(recipient),\r\n            cc: formatAddressList(cc),\r\n            bcc: formatAddressList(bcc),\r\n            subject,\r\n            html: htmlBody,\r\n            attachments: formatAttachments(attachments),\r\n        };\r\n\r\n        const info = await transporter.sendMail(mailOptions);\r\n\r\n        console.log(`📤 Email sent to ${mailOptions.to.join(\", \")} | ID: ${info.messageId}`);\r\n        return { status: true, messageId: info.messageId };\r\n    } catch (error) {\r\n        // Specify a type other than 'any' for the error\r\n        if (error instanceof Error) {\r\n            console.error(\"❌ Email Error:\", error.message);\r\n            return { status: false, error: error.message };\r\n        } else {\r\n            console.error(\"❌ Unknown Error:\", error);\r\n            return { status: false, error: \"Unknown error occurred\" };\r\n        }\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;AAAA;;AAwCO,eAAe,UAClB,MAAkB,EAClB,QAAkB;IAElB,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,UAAU,EAAE,SAAS,EAAE,GAAG;IAC1E,MAAM,EACF,YAAY,EAAE,EACd,KAAK,EAAE,EACP,MAAM,EAAE,EACR,OAAO,EACP,QAAQ,EACR,cAAc,EAAE,EACnB,GAAG;IAEJ,MAAM,oBAAoB,CAAC,OACvB,MAAM,OAAO,CAAC,QAAQ,KAAK,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,GAAK,GAAG,KAAK,EAAE,EAAE,MAAM,CAAC,CAAC,IAAI,EAAE;IAElF,MAAM,oBAAoB,CAAC,OACvB,KAAK,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,GAAK,CAAC;gBAC1B,UAAU;gBACV,MAAM;YACV,CAAC;IAEL,IAAI;QACA,MAAM,cAAc,iJAAA,CAAA,UAAU,CAAC,eAAe,CAAC;YAC3C;YACA,MAAM,OAAO;YACb;YACA,MAAM;gBAAE,MAAM;gBAAU,MAAM;YAAS;QAC3C;QAEA,MAAM,cAAc;YAChB,MAAM,GAAG,UAAU,EAAE,EAAE,WAAW,CAAC,CAAC;YACpC,IAAI,kBAAkB;YACtB,IAAI,kBAAkB;YACtB,KAAK,kBAAkB;YACvB;YACA,MAAM;YACN,aAAa,kBAAkB;QACnC;QAEA,MAAM,OAAO,MAAM,YAAY,QAAQ,CAAC;QAExC,QAAQ,GAAG,CAAC,CAAC,iBAAiB,EAAE,YAAY,EAAE,CAAC,IAAI,CAAC,MAAM,OAAO,EAAE,KAAK,SAAS,EAAE;QACnF,OAAO;YAAE,QAAQ;YAAM,WAAW,KAAK,SAAS;QAAC;IACrD,EAAE,OAAO,OAAO;QACZ,gDAAgD;QAChD,IAAI,iBAAiB,OAAO;YACxB,QAAQ,KAAK,CAAC,kBAAkB,MAAM,OAAO;YAC7C,OAAO;gBAAE,QAAQ;gBAAO,OAAO,MAAM,OAAO;YAAC;QACjD,OAAO;YACH,QAAQ,KAAK,CAAC,oBAAoB;YAClC,OAAO;gBAAE,QAAQ;gBAAO,OAAO;YAAyB;QAC5D;IACJ;AACJ","debugId":null}},
    {"offset": {"line": 488, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Webstep2/shipping-owl/src/utils/commonUtils.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\r\nimport prisma from \"@/lib/prisma\";\r\nimport { UAParser } from 'ua-parser-js';\r\n\r\ninterface ActivityLogParams {\r\n    adminId: number;\r\n    adminRole: string;\r\n    module: string;\r\n    action: string;\r\n    endpoint: string;\r\n    method: string;\r\n    payload: unknown;\r\n    response: unknown;\r\n    result: boolean;\r\n    data?: unknown;\r\n    ipv4?: string;\r\n    ipv6?: string;\r\n    internetServiceProvider?: string;\r\n    clientInformation?: string;\r\n    userAgent?: string;\r\n}\r\n\r\nexport async function logMessage<T>(type: string, message: string, item?: T): Promise<void> {\r\n    try {\r\n        const isDev = process.env.DEBUG === 'true' || process.env.NODE_ENV === 'development';\r\n        if (!isDev) return;\r\n\r\n        const logWithMessage = (logFn: (...args: unknown[]) => void, prefix = '') => {\r\n            if (item !== undefined) {\r\n                logFn(`${prefix}${message}`, item);\r\n            } else {\r\n                logFn(`${prefix}${message}`);\r\n            }\r\n        };\r\n\r\n        switch (type.toLowerCase()) {\r\n            case 'error':\r\n                logWithMessage(console.error, '❌ ');\r\n                break;\r\n            case 'warn':\r\n                logWithMessage(console.warn, '⚠️ ');\r\n                break;\r\n            case 'info':\r\n                logWithMessage(console.info, 'ℹ️ ');\r\n                break;\r\n            case 'debug':\r\n                logWithMessage(console.debug, '🔍 ');\r\n                break;\r\n            case 'log':\r\n                logWithMessage(console.log);\r\n                break;\r\n            case 'trace':\r\n                logWithMessage(console.trace, '🔍 ');\r\n                break;\r\n            case 'table':\r\n                if (item !== undefined) console.table(item);\r\n                break;\r\n            case 'group':\r\n                console.group(message);\r\n                break;\r\n            case 'groupend':\r\n                console.groupEnd();\r\n                break;\r\n            default:\r\n                logWithMessage(console.log, '📌 ');\r\n                break;\r\n        }\r\n    } catch (error) {\r\n        console.error('❌ Error in logMessage:', error);\r\n    }\r\n}\r\n\r\nexport async function ActivityLog(params: ActivityLogParams): Promise<void> {\r\n    try {\r\n        const {\r\n            adminId,\r\n            adminRole,\r\n            module,\r\n            action,\r\n            endpoint,\r\n            method,\r\n            payload,\r\n            response,\r\n            result,\r\n            data,\r\n            ipv4,\r\n            ipv6,\r\n            internetServiceProvider,\r\n            clientInformation,\r\n            userAgent,\r\n        } = params;\r\n\r\n        // Save the activity log to the database\r\n        const activityLog = await prisma.activityLog.create({\r\n            data: {\r\n                adminId,\r\n                adminRole,\r\n                module,\r\n                action,\r\n                endpoint,\r\n                method,\r\n                payload: JSON.stringify(payload), // store as JSON string if it's an object\r\n                response: JSON.stringify(response), // store as JSON string\r\n                result,\r\n                data: data ? JSON.stringify(data) : null, // optional field\r\n                ipv4,\r\n                ipv6,\r\n                internetServiceProvider,\r\n                clientInformation,\r\n                userAgent\r\n            }\r\n        });\r\n\r\n        console.info('Activity Log saved successfully:', activityLog);\r\n    } catch (error) {\r\n        console.error('❌ Error saving activity log:', error);\r\n    }\r\n}\r\n\r\nexport async function fetchLogInfo(module: string, action: string, req: NextRequest): Promise<void> {\r\n    try {\r\n        // Get the IP address from the 'x-forwarded-for' header or fallback to 'host' header\r\n        const forwardedFor = req.headers.get('x-forwarded-for');\r\n        const ipAddress = forwardedFor ? forwardedFor.split(',')[0] : req.headers.get('host');\r\n\r\n        // Construct the full URL\r\n        const protocol = req.headers.get('x-forwarded-proto') || 'http'; // Default to 'http' if missing\r\n        const host = req.headers.get('host'); // Get host from headers\r\n        const url = `${protocol}://${host}${req.nextUrl.pathname}${req.nextUrl.search || ''}`; // Build complete URL\r\n\r\n        // Get the HTTP method and the payload if applicable (POST, PUT, PATCH)\r\n        const method = req.method;\r\n        let payload: unknown = null;\r\n        if (['POST', 'PUT', 'PATCH'].includes(method)) {\r\n            try {\r\n                payload = await req.json(); // Parse JSON payload\r\n            } catch (error) {\r\n                console.error('❌ Error parsing request body:', error);\r\n            }\r\n        }\r\n\r\n        // Parse the User-Agent string for client details\r\n        const userAgent = req.headers.get('user-agent') || 'Unknown';\r\n        const parser = new UAParser(userAgent);\r\n        const clientInfo = parser.getResult();\r\n\r\n        // Extract browser, OS, and device details\r\n        const { browser, os, device } = clientInfo;\r\n        const browserName = browser.name || 'Unknown Browser';\r\n        const browserVersion = browser.version || 'Unknown Version';\r\n        const osName = os.name || 'Unknown OS';\r\n        const osVersion = os.version || 'Unknown OS Version';\r\n        const deviceType = device.type || 'Unknown Device';\r\n\r\n        // Log the gathered information\r\n        const logInfo = {\r\n            module,        // The module triggering the action\r\n            action,        // Specific action being logged\r\n            url,           // Full URL of the request\r\n            method,        // HTTP method (GET, POST, PUT, etc.)\r\n            payload,       // Payload for POST, PUT, PATCH requests\r\n            response: true, // Placeholder for response status (can be updated)\r\n            result: [],    // Placeholder for result (can be updated)\r\n            data: [],      // Placeholder for additional data (can be updated)\r\n            ipAddress,     // IP address from request\r\n            clientInfo: {  // Parsed client details\r\n                browser: browserName,\r\n                browserVersion,\r\n                os: osName,\r\n                osVersion,\r\n                device: deviceType\r\n            },\r\n            userAgent,     // Raw User-Agent string\r\n        };\r\n\r\n        // Example of logging the activity info\r\n        logMessage('info', `Activity log Info:`, logInfo);\r\n\r\n    } catch (error) {\r\n        console.error('❌ Error saving activity log:', error);\r\n    }\r\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 640, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Webstep2/shipping-owl/src/app/models/staffPermission.ts"],"sourcesContent":["import prisma from \"@/lib/prisma\";\r\n\r\nconst serializeBigInt = <T>(obj: T): T => {\r\n    if (typeof obj === \"bigint\") return obj.toString() as unknown as T;\r\n    if (obj instanceof Date) return obj;\r\n    if (Array.isArray(obj)) return obj.map(serializeBigInt) as unknown as T;\r\n    if (obj && typeof obj === \"object\") {\r\n        return Object.fromEntries(\r\n            Object.entries(obj).map(([key, value]) => [key, serializeBigInt(value)])\r\n        ) as T;\r\n    }\r\n    return obj;\r\n};\r\n\r\ninterface StaffPermissionFilter {\r\n    panel?: string;\r\n    module?: string;\r\n    action?: string;\r\n}\r\n\r\n// 🔍 Professional: Filter by panel, module, action (any or all)\r\nexport const getStaffPermissions = async (filter: StaffPermissionFilter = {}) => {\r\n    try {\r\n        const staffPermissions = await prisma.adminStaffPermission.findMany({\r\n            where: {\r\n                ...(filter.panel && { panel: filter.panel }),\r\n                ...(filter.module && { module: filter.module }),\r\n                ...(filter.action && { action: filter.action }),\r\n            },\r\n            orderBy: { id: \"desc\" },\r\n        });\r\n\r\n        return {\r\n            status: true,\r\n            staffPermissions: serializeBigInt(staffPermissions),\r\n        };\r\n    } catch (error) {\r\n        console.error(\"❌ getStaffPermissions Error:\", error);\r\n        return {\r\n            status: false,\r\n            message: \"Error fetching staff permissions\",\r\n        };\r\n    }\r\n};\r\n\r\nexport const checkStaffPermissionStatus = async (filter: StaffPermissionFilter = {}, staffId: number) => {\r\n    try {\r\n\r\n        if (!staffId || isNaN(staffId)) {\r\n            return {\r\n                status: false,\r\n                message: \"Invalid staff ID\",\r\n            };\r\n        }\r\n\r\n        // Fetch staff permissions based on the provided filter and staff ID\r\n        if (!filter.panel || !filter.module || !filter.action) {\r\n            return {\r\n                status: false,\r\n                message: \"all of filter must be provided\",\r\n            };\r\n        }\r\n\r\n        const isValidPanel = [\"admin\", \"supplier\", \"customer\"].includes(filter.panel);\r\n        if (!isValidPanel) {\r\n            return {\r\n                status: false,\r\n                message: \"Invalid panel provided\",\r\n            };\r\n        }\r\n\r\n        const staffPermissionsExist = await prisma.adminStaffPermission.findFirst({\r\n            where: {\r\n                panel: filter.panel,\r\n                module: filter.module,\r\n                action: filter.action\r\n            },\r\n        });\r\n\r\n        if (!staffPermissionsExist) {\r\n            return {\r\n                status: false,\r\n                message: \"No permissions found for the given filter\",\r\n            };\r\n        }\r\n\r\n        const staffPermissions = await prisma.adminStaffHasPermission.findFirst({\r\n            where: {\r\n                adminStaffPermissionId: staffPermissionsExist.id,\r\n                adminStaffId: staffId\r\n            },\r\n            orderBy: { id: \"desc\" },\r\n        });\r\n\r\n        if (!staffPermissions) {\r\n            return {\r\n                status: false,\r\n                message: \"Action Unauthorized\",\r\n            };\r\n        }\r\n\r\n        return {\r\n            status: true,\r\n            message: \"Action Authorized\",\r\n        };\r\n    } catch (error) {\r\n        console.error(\"❌ getStaffPermissions Error:\", error);\r\n        return {\r\n            status: false,\r\n            message: \"Error fetching staff permissions\",\r\n        };\r\n    }\r\n};\r\n\r\nexport const getStaffPermissionsByStaffId = async (filter: StaffPermissionFilter = {}, staffId: number) => {\r\n    try {\r\n        // Validate staff ID\r\n        if (!staffId || isNaN(staffId)) {\r\n            return {\r\n                status: false,\r\n                message: \"Invalid staff ID\",\r\n            };\r\n        }\r\n\r\n        // Validate panel if provided\r\n        if (filter.panel) {\r\n            const isValidPanel = [\"admin\", \"supplier\", \"customer\", \"dropshipper\"].includes(filter.panel);\r\n            if (!isValidPanel) {\r\n                return {\r\n                    status: false,\r\n                    message: \"Invalid panel provided\",\r\n                };\r\n            }\r\n        }\r\n\r\n        // Fetch permissions matching the filter\r\n        const matchingPermissions = await prisma.adminStaffPermission.findMany({\r\n            where: {\r\n                ...(filter.panel && { panel: filter.panel }),\r\n                ...(filter.module && { module: filter.module }),\r\n                ...(filter.action && { action: filter.action }),\r\n            },\r\n            orderBy: { id: 'desc' },\r\n        });\r\n\r\n        if (!matchingPermissions.length) {\r\n            return {\r\n                status: false,\r\n                message: \"No matching permissions found for the given filter\",\r\n            };\r\n        }\r\n\r\n        const permissionIds = matchingPermissions.map(p => p.id);\r\n\r\n        // Get all permissions assigned to the staff from filtered list\r\n        const assignedPermissions = await prisma.adminStaffHasPermission.findMany({\r\n            where: {\r\n                adminStaffPermissionId: {\r\n                    in: permissionIds,\r\n                },\r\n                adminStaffId: staffId,\r\n            },\r\n            include: {\r\n                permission: true, // optional: if you want full permission data from relation\r\n            },\r\n            orderBy: { id: 'desc' },\r\n        });\r\n\r\n        if (!assignedPermissions.length) {\r\n            return {\r\n                status: false,\r\n                message: \"No permissions assigned to this staff for the given filter\",\r\n            };\r\n        }\r\n\r\n        return {\r\n            status: true,\r\n            message: \"Permissions retrieved successfully\",\r\n            assignedPermissions,\r\n        };\r\n    } catch (error) {\r\n        console.error(\"❌ getStaffPermissionsByStaffId Error:\", error);\r\n        return {\r\n            status: false,\r\n            message: \"Error retrieving staff permissions\",\r\n        };\r\n    }\r\n};\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 843, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Webstep2/shipping-owl/src/app/controllers/admin/authController.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport prisma from \"@/lib/prisma\";\r\nimport { generateToken, generatePasswordResetToken } from '@/utils/auth/authUtils';\r\nimport { comparePassword } from '@/utils/hashUtils';\r\nimport { verifyToken } from '@/utils/auth/authUtils';\r\nimport { getEmailConfig } from '@/app/models/admin/emailConfig';\r\nimport { sendEmail } from \"@/utils/email/sendEmail\";\r\nimport bcrypt from 'bcryptjs';\r\nimport { logMessage } from '@/utils/commonUtils';\r\nimport { getStaffPermissionsByStaffId } from '@/app/models/staffPermission';\r\n\r\ninterface Admin {\r\n    id: number;\r\n    name: string;\r\n    email: string;\r\n    role: string;\r\n    createdAt: Date;\r\n}\r\n\r\nexport async function handleLogin(req: NextRequest, adminRole: string, adminStaffRole: string) {\r\n    try {\r\n        const { email, password } = await req.json();\r\n\r\n        // Hash the password using bcrypt\r\n        const salt = await bcrypt.genSalt(10); // Generates a salt with 10 rounds\r\n        const hashedPassword = await bcrypt.hash(password, salt);\r\n\r\n        console.log(`Hashed Password: ${hashedPassword}`); // Log the hashed password\r\n\r\n        // Fetch admin by email and role\r\n        let type = 'main';\r\n        let adminResponse = await adminByUsernameRole(email, adminRole);\r\n        if (!adminResponse.status || !adminResponse.admin) {\r\n            adminResponse = await adminByUsernameRole(email, adminStaffRole);\r\n            type = 'sub';\r\n            if (!adminResponse.status || !adminResponse.admin) {\r\n                return NextResponse.json({ message: adminResponse.message || \"Invalid email or password\", status: false }, { status: 401 });\r\n            }\r\n        }\r\n\r\n        const admin = adminResponse.admin;\r\n\r\n        console.log(`admin - `, admin);\r\n\r\n        // Correct usage of .toLowerCase() as a function\r\n        if (admin.status.toLowerCase() !== 'active') {\r\n            return NextResponse.json(\r\n                { message: \"Admin account is not active\", status: false },\r\n                { status: 403 }\r\n            );\r\n        }\r\n\r\n        // Compare the provided password with the stored hash\r\n        const isPasswordValid = await comparePassword(password, admin.password);\r\n        if (!isPasswordValid) {\r\n            return NextResponse.json({ message: 'Invalid email or password', status: false }, { status: 401 });\r\n        }\r\n\r\n        // Email & account verification checks for supplier\r\n        if (type === 'main' && admin.role === 'supplier') {\r\n            if ('isEmailVerified' in admin && !admin?.isEmailVerified) {\r\n                return NextResponse.json(\r\n                    { status: false, message: \"Email is not verified yet\" },\r\n                    { status: 403 }\r\n                );\r\n            }\r\n\r\n            if ('isVerified' in admin && !admin?.isVerified) {\r\n                return NextResponse.json(\r\n                    { status: false, message: \"Your account has not been verified by admin\" },\r\n                    { status: 403 }\r\n                );\r\n            }\r\n        }\r\n\r\n        if (type === 'sub' && 'admin' in admin && admin.admin?.role === 'supplier') {\r\n            if ('admin' in admin && !admin.admin.isEmailVerified) {\r\n                return NextResponse.json({ status: false, message: \"Main account's email is not verified yet\" }, { status: 403 });\r\n            }\r\n            if ('admin' in admin && !admin.admin.isVerified) {\r\n                return NextResponse.json({ status: false, message: \"Main account is not yet verified by admin\" }, { status: 403 });\r\n            }\r\n        }\r\n\r\n        // Generate authentication token\r\n        const token = generateToken(admin.id, admin.role);\r\n\r\n        const isStaffUser = !['admin', 'dropshipper', 'supplier'].includes(String(admin.role));\r\n        let assignedPermissions;\r\n        if (isStaffUser) {\r\n            console.log(`AdminStaff`);\r\n            const options = {\r\n                panel: 'admin'\r\n            };\r\n            const assignedPermissionsResult = await getStaffPermissionsByStaffId(options, admin.id);\r\n            assignedPermissions = assignedPermissionsResult.assignedPermissions;\r\n        }\r\n\r\n        return NextResponse.json({\r\n            message: \"Login successful\",\r\n            token,\r\n            admin: {\r\n                id: admin.id,\r\n                name: admin.name,\r\n                email: admin.email,\r\n                role: admin.role,\r\n            },\r\n            assignedPermissions\r\n        });\r\n    } catch (error) {\r\n        console.error(`Error during login:`, error);\r\n        return NextResponse.json({ message: \"Internal Server Error\", status: false }, { status: 500 });\r\n    }\r\n}\r\n\r\nexport async function handleVerifyLogin(req: NextRequest, adminRole: string, adminStaffRole: string) {\r\n    try {\r\n        // Extract token from Authorization header\r\n        const token = req.headers.get('authorization')?.split(' ')[1];\r\n        if (!token) {\r\n            return NextResponse.json({ message: 'No token provided', status: false }, { status: 401 });\r\n        }\r\n\r\n        // Use adminByToken to verify token and fetch admin details\r\n        const { status, message, admin } = await adminByToken(token, adminRole, adminStaffRole);\r\n\r\n        if (!status) {\r\n            return NextResponse.json({ message: message || \"Invalid email or password\", status: false }, { status: 401 });\r\n        }\r\n\r\n        return NextResponse.json({ message: \"Token is valid\", admin, status: true });\r\n    } catch (error) {\r\n        console.error(`error - `, error);\r\n        return NextResponse.json({ message: \"Internal Server Error\", status: false }, { status: 500 });\r\n    }\r\n}\r\n\r\nexport async function handleForgetPassword(\r\n    req: NextRequest,\r\n    panel: string,\r\n    adminRole: string,\r\n    adminStaffRole: string\r\n) {\r\n    try {\r\n        const { email } = await req.json();\r\n\r\n        if (!email) {\r\n            return NextResponse.json(\r\n                { message: \"Email is required.\", status: false },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Attempt to fetch admin or adminStaff by email\r\n        let userResponse = await adminByUsernameRole(email, adminRole);\r\n        if (!userResponse.status || !userResponse.admin) {\r\n            userResponse = await adminByUsernameRole(email, adminStaffRole);\r\n            if (!userResponse.status || !userResponse.admin) {\r\n                return NextResponse.json(\r\n                    {\r\n                        message: \"No account found with this email.\",\r\n                        status: false,\r\n                    },\r\n                    { status: 404 }\r\n                );\r\n            }\r\n        }\r\n\r\n        const admin = userResponse.admin;\r\n        const token = generatePasswordResetToken(admin.id, admin.role);\r\n        const expiry = new Date(Date.now() + 60 * 60 * 1000); // 1 hour\r\n\r\n        // Update token and expiry in database\r\n        const updateData = {\r\n            pr_token: token,\r\n            pr_expires_at: expiry,\r\n        };\r\n\r\n        if (admin.role === adminRole) {\r\n            await prisma.admin.update({ where: { id: admin.id }, data: updateData });\r\n        } else {\r\n            await prisma.adminStaff.update({ where: { id: admin.id }, data: updateData });\r\n        }\r\n\r\n        // Optional: Send email\r\n        // await sendPasswordResetEmail(admin.email, token);\r\n        const { status: emailStatus, message: emailMessage, emailConfig, htmlTemplate, subject: emailSubject } = await getEmailConfig(\"admin\", \"auth\", \"forget-password\", true);\r\n        logMessage('debug', 'Email Config:', emailConfig);\r\n\r\n        if (!emailStatus || !emailConfig) {\r\n            return NextResponse.json(\r\n                { message: emailMessage || \"Failed to fetch email configuration.\", status: false },\r\n                { status: 500 }\r\n            );\r\n        }\r\n\r\n        let urlPanel;\r\n        if (panel == 'dropshipper') {\r\n            urlPanel = `https://shipowl.io/dropshipping/auth/password/reset?token=${token}`;\r\n        } else {\r\n            urlPanel = `https://shipowl.io/${panel}/auth/password/reset?token=${token}`;\r\n        }\r\n\r\n        // Use index signature to avoid TS error\r\n        const replacements: Record<string, string> = {\r\n            \"{{name}}\": admin.name,\r\n            \"{{resetUrl}}\": urlPanel,\r\n            \"{{year}}\": new Date().getFullYear().toString(),\r\n            \"{{appName}}\": \"Shipping OWL\",\r\n        };\r\n\r\n        let htmlBody = htmlTemplate?.trim()\r\n            ? htmlTemplate\r\n            : \"<p>Dear {{name}},</p><p>Click <a href='{{resetUrl}}'>here</a> to reset your password.</p>\";\r\n\r\n        Object.keys(replacements).forEach((key) => {\r\n            htmlBody = htmlBody.replace(new RegExp(key, \"g\"), replacements[key]);\r\n        });\r\n\r\n        logMessage('debug', 'HTML Body:', htmlBody);\r\n\r\n        let subject = emailSubject;\r\n        Object.keys(replacements).forEach((key) => {\r\n            subject = subject.replace(new RegExp(key, \"g\"), replacements[key]);\r\n        });\r\n\r\n        const mailData = {\r\n            recipient: [\r\n                { name: admin.name, email }\r\n            ],\r\n            cc: [],\r\n            bcc: [],\r\n            subject,\r\n            htmlBody,\r\n            attachments: [],\r\n        };\r\n\r\n        const emailResult = await sendEmail(emailConfig, mailData);\r\n\r\n        if (!emailResult.status) {\r\n            return NextResponse.json(\r\n                {\r\n                    message: \"Reset token created but failed to send email. Please try again.\",\r\n                    status: false,\r\n                    emailError: emailResult.error,\r\n                },\r\n                { status: 500 }\r\n            );\r\n        }\r\n\r\n        return NextResponse.json(\r\n            {\r\n                message: \"Password reset link has been sent to your email.\",\r\n                status: true,\r\n            },\r\n            { status: 200 }\r\n        );\r\n\r\n    } catch (error) {\r\n        console.error(\"❌ Forgot password error:\", error);\r\n        return NextResponse.json(\r\n            { message: \"Something went wrong. Please try again later.\", status: false },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n\r\nexport async function handleResetPassword(\r\n    req: NextRequest,\r\n    adminRole: string,\r\n    adminStaffRole: string\r\n) {\r\n    try {\r\n        const { token, password } = await req.json();\r\n\r\n        // Check if token is provided\r\n        if (!token) {\r\n            return NextResponse.json(\r\n                { message: \"Token is required.\", status: false },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Verify token and fetch admin details using adminByToken function\r\n        const { status: tokenStatus, message: tokenMessage, admin } = await adminByToken(token, adminRole, adminStaffRole);\r\n\r\n        if (!tokenStatus || !admin) {\r\n            return NextResponse.json(\r\n                { status: false, message: tokenMessage || \"Invalid token or role.\" },\r\n                { status: 401 }\r\n            );\r\n        }\r\n\r\n        // Hash the password using bcrypt\r\n        const hashedPassword = await bcrypt.hash(password, await bcrypt.genSalt(10));\r\n\r\n        // Prepare the update data\r\n        const updateData = {\r\n            pr_token: null,\r\n            pr_expires_at: null,\r\n            pr_last_reset: new Date(),\r\n            password: hashedPassword,\r\n        };\r\n\r\n        // Update the admin or admin staff record based on the role\r\n        if (admin.role === adminRole) {\r\n            await prisma.admin.update({\r\n                where: { id: admin.id },\r\n                data: updateData,\r\n            });\r\n        } else {\r\n            await prisma.adminStaff.update({\r\n                where: { id: admin.id },\r\n                data: updateData,\r\n            });\r\n        }\r\n\r\n        const { status: emailStatus, message: emailMessage, emailConfig, htmlTemplate, subject: emailSubject } = await getEmailConfig(\"admin\", \"auth\", \"reset-password\", true);\r\n        logMessage('debug', 'Email Config:', emailConfig);\r\n\r\n        if (!emailStatus || !emailConfig) {\r\n            return NextResponse.json(\r\n                { message: emailMessage || \"Failed to fetch email configuration.\", status: false },\r\n                { status: 500 }\r\n            );\r\n        }\r\n\r\n        // Use index signature to avoid TS error\r\n        const replacements: Record<string, string> = {\r\n            \"{{name}}\": admin.name,\r\n            \"{{year}}\": new Date().getFullYear().toString(),\r\n            \"{{appName}}\": \"Shipping OWL\",\r\n        };\r\n\r\n        let htmlBody = htmlTemplate?.trim()\r\n            ? htmlTemplate\r\n            : \"<p>Dear {{name}},</p><p>Your password has been reset successfully.</p>\";\r\n\r\n        // Replace placeholders in the HTML template\r\n        Object.keys(replacements).forEach((key) => {\r\n            htmlBody = htmlBody.replace(new RegExp(key, \"g\"), replacements[key]);\r\n        });\r\n\r\n        let subject = emailSubject;\r\n        Object.keys(replacements).forEach((key) => {\r\n            subject = subject.replace(new RegExp(key, \"g\"), replacements[key]);\r\n        });\r\n\r\n        logMessage('debug', 'HTML Body:', htmlBody);\r\n\r\n        const mailData = {\r\n            recipient: [\r\n                { name: admin.name, email: admin.email },\r\n            ],\r\n            subject,\r\n            htmlBody,\r\n            attachments: [],\r\n        };\r\n\r\n        // Send email notification\r\n        const emailResult = await sendEmail(emailConfig, mailData);\r\n\r\n        if (!emailResult.status) {\r\n            return NextResponse.json(\r\n                {\r\n                    message: \"Password reset successful, but failed to send email notification.\",\r\n                    status: false,\r\n                    emailError: emailResult.error,\r\n                },\r\n                { status: 500 }\r\n            );\r\n        }\r\n\r\n        // Return success response\r\n        return NextResponse.json(\r\n            {\r\n                message: \"Password reset successful. A notification has been sent to your email.\",\r\n                status: true,\r\n            },\r\n            { status: 200 }\r\n        );\r\n\r\n    } catch (error) {\r\n        console.error(\"❌ Password reset error:\", error);\r\n        return NextResponse.json(\r\n            { message: \"An error occurred while resetting the password. Please try again later.\", status: false },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n\r\nexport async function handleVerifyStatus(\r\n    req: NextRequest,\r\n    adminRole: string,\r\n    adminStaffRole: string\r\n) {\r\n    try {\r\n        const { token } = await req.json();\r\n\r\n        // Check if token is provided\r\n        if (!token) {\r\n            return NextResponse.json(\r\n                { message: \"Token is required.\", status: false },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Verify token and fetch admin details using adminByToken function\r\n        const { status: tokenStatus, message: tokenMessage, admin } = await adminByToken(token, adminRole, adminStaffRole);\r\n\r\n        if (!tokenStatus || !admin) {\r\n            return NextResponse.json(\r\n                { status: false, message: tokenMessage || \"Invalid token or role.\" },\r\n                { status: 401 }\r\n            );\r\n        }\r\n\r\n        let loginLink;\r\n\r\n        // Update the admin or admin staff record based on the role\r\n        if (adminRole == 'supplier') {\r\n            // Prepare the update data\r\n            const updateAdminData = {\r\n                isEmailVerified: true,\r\n                emailVerifiedAt: new Date()\r\n            };\r\n\r\n            const updateStaffData = {\r\n                status: 'active'\r\n            };\r\n\r\n            if (admin.role === adminRole) {\r\n                await prisma.admin.update({\r\n                    where: { id: admin.id },\r\n                    data: updateAdminData,\r\n                });\r\n            } else {\r\n                await prisma.adminStaff.update({\r\n                    where: { id: admin.id },\r\n                    data: updateStaffData,\r\n                });\r\n            }\r\n            loginLink = `https://shipowl.io/supplier/auth/login`;\r\n        } else if (adminRole == 'dropshipper') {\r\n            // Prepare the update data\r\n            const updateData = {\r\n                status: 'active'\r\n            };\r\n\r\n            if (admin.role === adminRole) {\r\n                await prisma.admin.update({\r\n                    where: { id: admin.id },\r\n                    data: updateData,\r\n                });\r\n            } else {\r\n                await prisma.adminStaff.update({\r\n                    where: { id: admin.id },\r\n                    data: updateData,\r\n                });\r\n            }\r\n            loginLink = `https://shipowl.io/dropshipping/auth/login`;\r\n\r\n        } else {\r\n            return NextResponse.json(\r\n                { status: false, message: \"Role is not supproted for this action\" },\r\n                { status: 500 }\r\n            );\r\n        }\r\n\r\n        const { status: emailStatus, message: emailMessage, emailConfig, htmlTemplate, subject: emailSubject } = await getEmailConfig(adminRole, 'auth', 'verify', true);\r\n        logMessage('debug', 'Email Config:', emailConfig);\r\n\r\n        if (!emailStatus || !emailConfig) {\r\n            return NextResponse.json(\r\n                { message: emailMessage || \"Failed to fetch email configuration.\", status: false },\r\n                { status: 500 }\r\n            );\r\n        }\r\n\r\n        // Use index signature to avoid TS error\r\n        const replacements: Record<string, string> = {\r\n            \"{{name}}\": admin.name,\r\n            \"{{year}}\": new Date().getFullYear().toString(),\r\n            \"{{loginLink}}\": loginLink,\r\n            \"{{appName}}\": \"Shipping OWL\",\r\n        };\r\n\r\n        let htmlBody = htmlTemplate?.trim()\r\n            ? htmlTemplate\r\n            : \"<p>Dear {{name}},</p><p>Your account has been verified successfully.</p>\";\r\n\r\n        // Replace placeholders in the HTML template\r\n        Object.keys(replacements).forEach((key) => {\r\n            htmlBody = htmlBody.replace(new RegExp(key, \"g\"), replacements[key]);\r\n        });\r\n\r\n        let subject = emailSubject;\r\n        Object.keys(replacements).forEach((key) => {\r\n            subject = subject.replace(new RegExp(key, \"g\"), replacements[key]);\r\n        });\r\n\r\n        logMessage('debug', 'HTML Body:', htmlBody);\r\n\r\n        const mailData = {\r\n            recipient: [\r\n                { name: admin.name, email: admin.email },\r\n            ],\r\n            subject,\r\n            htmlBody,\r\n            attachments: [],\r\n        };\r\n\r\n        // Send email notification\r\n        const emailResult = await sendEmail(emailConfig, mailData);\r\n\r\n        if (!emailResult.status) {\r\n            return NextResponse.json(\r\n                {\r\n                    message: \"Account Verified successful, but failed to send email notification.\",\r\n                    status: false,\r\n                    emailError: emailResult.error,\r\n                },\r\n                { status: 500 }\r\n            );\r\n        }\r\n\r\n        // Return success response\r\n        return NextResponse.json(\r\n            {\r\n                message: \"Account Verified successful. A notification has been sent to your email.\",\r\n                status: true,\r\n            },\r\n            { status: 200 }\r\n        );\r\n\r\n    } catch (error) {\r\n        console.error(\"❌ Account Verified error:\", error);\r\n        return NextResponse.json(\r\n            { message: \"An error occurred while verifing the account. Please try again later.\", status: false },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n\r\nexport async function adminByUsernameRole(username: string, role: string) {\r\n    try {\r\n\r\n        const adminRoleStr = String(role); // Ensure it's a string\r\n        const adminModel = [\"admin\", \"dropshipper\", \"supplier\"].includes(adminRoleStr) ? \"admin\" : \"adminStaff\";\r\n        console.log(`adminRoleStr - `, adminRoleStr);\r\n\r\n        // Fetch admin details from database\r\n        let admin\r\n        if (adminModel === \"admin\") {\r\n            admin = await prisma.admin.findFirst({\r\n                where: { email: username, role },\r\n                select: {\r\n                    id: true,\r\n                    name: true,\r\n                    email: true,\r\n                    password: true,\r\n                    role: true,\r\n                    status: true,\r\n                    isVerified: true,\r\n                    isEmailVerified: true,\r\n                },\r\n            });\r\n        } else {\r\n            admin = await prisma.adminStaff.findFirst({\r\n                where: { email: username, role },\r\n                select: {\r\n                    id: true,\r\n                    name: true,\r\n                    email: true,\r\n                    password: true,\r\n                    role: true,\r\n                    status: true,\r\n                    admin: true\r\n                },\r\n            });\r\n        }\r\n\r\n        // If admin doesn't exist, return false with a message\r\n        if (!admin) {\r\n            return { status: false, message: \"User with the provided ID does not exist\" };\r\n        }\r\n\r\n        return { status: true, admin };\r\n    } catch (error) {\r\n        console.error(`Error fetching admin:`, error);\r\n        return { status: false, message: \"Internal Server Error\" };\r\n    }\r\n}\r\n\r\nexport async function adminByToken(\r\n    token: string,\r\n    adminRole: string,\r\n    adminStaffRole: string\r\n): Promise<{ status: boolean, message: string, admin?: Admin }> {\r\n    try {\r\n        // Verify token and extract admin details\r\n        const { payload, status, message } = await verifyToken(token);\r\n        if (!status || !payload || typeof payload.adminId !== 'number') {\r\n            return { status: false, message: message || \"Unauthorized access. Invalid token.\" };\r\n        }\r\n\r\n        // Determine the admin model based on role\r\n        const payloadAdminRole = String(payload.adminRole); // Ensure it's a string\r\n\r\n        if (![adminRole, adminStaffRole].includes(payloadAdminRole)) {\r\n            return { status: false, message: \"Access denied. Invalid role.\" };\r\n        }\r\n\r\n        // Set the correct admin model\r\n        const adminModel = [\"admin\", \"dropshipper\", \"supplier\"].includes(payloadAdminRole) ? \"admin\" : \"adminStaff\";\r\n\r\n        // Fetch the admin from the database\r\n        let admin: Admin | null;\r\n        if (adminModel === \"admin\") {\r\n            admin = await prisma.admin.findUnique({\r\n                where: { id: payload.adminId },\r\n                select: {\r\n                    id: true,\r\n                    name: true,\r\n                    email: true,\r\n                    role: true,\r\n                    createdAt: true,\r\n                },\r\n            });\r\n        } else {\r\n            admin = await prisma.adminStaff.findUnique({\r\n                where: { id: payload.adminId },\r\n                select: {\r\n                    id: true,\r\n                    name: true,\r\n                    email: true,\r\n                    role: true,\r\n                    createdAt: true,\r\n                },\r\n            });\r\n        }\r\n\r\n        // If admin not found, return error\r\n        if (!admin) {\r\n            return { status: false, message: \"Invalid admin credentials or account not found.\" };\r\n        }\r\n\r\n        // Return success with admin details\r\n        return { status: true, message: \"Token is valid\", admin };\r\n    } catch (error) {\r\n        console.error(\"Error fetching admin:\", error);\r\n        return { status: false, message: \"Internal Server Error\" };\r\n    }\r\n}\r\n\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1548, "column": 0}, "map": {"version":3,"sources":["file://D%3A/Webstep2/shipping-owl/src/app/api/dropshipper/auth/login/route.ts"],"sourcesContent":["import { handleLogin } from '../../../../controllers/admin/authController';\r\nimport { NextRequest } from 'next/server';\r\n\r\nexport async function POST(req: NextRequest) {\r\n    const adminRole = \"dropshipper\";\r\n    const adminStaffRole = \"dropshipper_staff\";\r\n    return handleLogin(req, adminRole, adminStaffRole);\r\n}\r\n"],"names":[],"mappings":";;;AAAA;;AAGO,eAAe,KAAK,GAAgB;IACvC,MAAM,YAAY;IAClB,MAAM,iBAAiB;IACvB,OAAO,CAAA,GAAA,sJAAA,CAAA,cAAW,AAAD,EAAE,KAAK,WAAW;AACvC","debugId":null}}]
}