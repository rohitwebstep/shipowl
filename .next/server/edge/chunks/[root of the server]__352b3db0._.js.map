{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 31, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/utils/authUtils.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport jwt from 'jsonwebtoken';\r\nimport { jwtVerify } from 'jose';\r\n\r\nconst SECRET_KEY = process.env.JWT_SECRET || '3792e68ef011e0f236a60627ddf304e1bb64d76d5e4dbebca4579490d3c4e6d8c618456f29aa6f92f8dc3cbd4414362b47d4545ffdc0b9549e43b629c39282bb36b9cff7295fc4269d765d59e4d8a811113b911080878f7647e0329a072afdc06d2ecd658c8e79f2ad04e74dbffc45ed10c850b02afdf10b209989910fadaf7ddbef0bb7d0cff27ed8f4a10d3415420107ddba2d9ac8bcf4f7b3b942b5bbe600d9007f9e88b2451cbfaeaab239677b3ed28eaa860eb40fd5d0e36969b6943a3215d2a9f1125ca06be806f8d73d8ae642c4a29b3a728cf42305e1150e4c1f3ed6e14bd3662531cd14357c6b3f3a57095609811f5e9459307cbe70f9b7a159c8d3';\r\n\r\nexport function generateToken(adminId: string) {\r\n    return jwt.sign({ adminId }, SECRET_KEY, { expiresIn: '1h' });\r\n}\r\n\r\n// export function verifyToken(token: string) {\r\n//     try {\r\n//         return jwt.verify(token, SECRET_KEY);\r\n//     } catch (error) {\r\n//         console.error('Token verification failed:', error);\r\n//         return null;\r\n//     }\r\n// }\r\n\r\nexport async function verifyToken(token: string) {\r\n    try {\r\n        const { payload } = await jwtVerify(token, new TextEncoder().encode(SECRET_KEY));\r\n        console.log(`payload - `, payload);\r\n        return payload;\r\n    } catch (error) {\r\n        console.error('Token verification failed:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function isAdminExist(adminId: string) {\r\n    try {\r\n        // Check if adminId is valid: must be a number or convertible to a number and not empty or null\r\n        if (!adminId || isNaN(Number(adminId)) || Number(adminId) <= 0) {\r\n            return NextResponse.json({\r\n                status: false,\r\n                message: \"Invalid admin ID. It must be a positive integer.\",\r\n            }, { status: 400 });\r\n        }\r\n\r\n        // Convert adminId to integer\r\n        const adminIdInt = parseInt(adminId, 10);\r\n\r\n        // Fetch the admin by primary key (id) from the database\r\n        const admin = await prisma.admin.findUnique({\r\n            where: { id: adminIdInt },\r\n            select: {\r\n                id: true,\r\n                name: true,\r\n                email: true,\r\n                password: true, // Hashed password stored in DB\r\n                role: true,\r\n            },\r\n        });\r\n\r\n        // If admin doesn't exist, return false with a message\r\n        if (!admin) {\r\n            return NextResponse.json({\r\n                status: false,\r\n                message: \"Admin with the provided ID does not exist\",\r\n            }, { status: 404 });\r\n        }\r\n\r\n        // If admin exists, return true with a success message\r\n        return NextResponse.json({\r\n            status: true,\r\n            message: \"Admin found\",\r\n            admin,\r\n        }, { status: 200 });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error fetching admin by ID:\", error);\r\n        return NextResponse.json({\r\n            status: false,\r\n            message: \"Internal Server Error\",\r\n        }, { status: 500 });\r\n    }\r\n}"],"names":[],"mappings":";;;;;AAAA;AAAA;AACA;AACA;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAEtC,SAAS,cAAc,OAAe;IACzC,OAAO,6IAAA,CAAA,UAAG,CAAC,IAAI,CAAC;QAAE;IAAQ,GAAG,YAAY;QAAE,WAAW;IAAK;AAC/D;AAWO,eAAe,YAAY,KAAa;IAC3C,IAAI;QACA,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,YAAS,AAAD,EAAE,OAAO,IAAI,cAAc,MAAM,CAAC;QACpE,QAAQ,GAAG,CAAC,CAAC,UAAU,CAAC,EAAE;QAC1B,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,8BAA8B;QAC5C,OAAO;IACX;AACJ;AAEO,eAAe,aAAa,OAAe;IAC9C,IAAI;QACA,+FAA+F;QAC/F,IAAI,CAAC,WAAW,MAAM,OAAO,aAAa,OAAO,YAAY,GAAG;YAC5D,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBACrB,QAAQ;gBACR,SAAS;YACb,GAAG;gBAAE,QAAQ;YAAI;QACrB;QAEA,6BAA6B;QAC7B,MAAM,aAAa,SAAS,SAAS;QAErC,wDAAwD;QACxD,MAAM,QAAQ,MAAM,OAAO,KAAK,CAAC,UAAU,CAAC;YACxC,OAAO;gBAAE,IAAI;YAAW;YACxB,QAAQ;gBACJ,IAAI;gBACJ,MAAM;gBACN,OAAO;gBACP,UAAU;gBACV,MAAM;YACV;QACJ;QAEA,sDAAsD;QACtD,IAAI,CAAC,OAAO;YACR,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBACrB,QAAQ;gBACR,SAAS;YACb,GAAG;gBAAE,QAAQ;YAAI;QACrB;QAEA,sDAAsD;QACtD,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACrB,QAAQ;YACR,SAAS;YACT;QACJ,GAAG;YAAE,QAAQ;QAAI;IAErB,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACrB,QAAQ;YACR,SAAS;QACb,GAAG;YAAE,QAAQ;QAAI;IACrB;AACJ"}},
    {"offset": {"line": 120, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middlewares/adminAuth.ts"],"sourcesContent":["// src/adminAuthMiddleware.ts\r\nimport { NextRequest, NextResponse } from \"next/server\";\r\nimport { verifyToken } from \"@/utils/authUtils\";\r\n\r\nexport async function adminAuthMiddleware(req: NextRequest) {\r\n    try {\r\n\r\n        // Extract token from Authorization header\r\n        const token = req.headers.get(\"authorization\")?.split(\" \")[1];\r\n        if (!token) {\r\n            return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\r\n        }\r\n\r\n        // Verify token and extract admin details\r\n        const decodedAdmin = await verifyToken(token);\r\n        if (!decodedAdmin || !decodedAdmin.adminId) {\r\n            return NextResponse.json({ error: \"Forbidden\" }, { status: 403 });\r\n        }\r\n\r\n        // Pass the adminId to the API route if needed (you could set it in the request header)\r\n        req.headers.set(\"x-admin-id\", decodedAdmin.adminId.toString());\r\n\r\n        return NextResponse.next();\r\n    } catch (error) {\r\n        return NextResponse.json({ error: \"Internal Server Error\" }, { status: 500 });\r\n    }\r\n}"],"names":[],"mappings":"AAAA,6BAA6B;;;;AAC7B;AAAA;AACA;;;AAEO,eAAe,oBAAoB,GAAgB;IACtD,IAAI;QAEA,0CAA0C;QAC1C,MAAM,QAAQ,IAAI,OAAO,CAAC,GAAG,CAAC,kBAAkB,MAAM,IAAI,CAAC,EAAE;QAC7D,IAAI,CAAC,OAAO;YACR,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACtE;QAEA,yCAAyC;QACzC,MAAM,eAAe,MAAM,CAAA,GAAA,iIAAA,CAAA,cAAW,AAAD,EAAE;QACvC,IAAI,CAAC,gBAAgB,CAAC,aAAa,OAAO,EAAE;YACxC,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAY,GAAG;gBAAE,QAAQ;YAAI;QACnE;QAEA,uFAAuF;QACvF,IAAI,OAAO,CAAC,GAAG,CAAC,cAAc,aAAa,OAAO,CAAC,QAAQ;QAE3D,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;IAC5B,EAAE,OAAO,OAAO;QACZ,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACJ"}},
    {"offset": {"line": 166, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["// src/middleware.ts\r\nimport { NextRequest, NextResponse } from \"next/server\";\r\nimport { adminAuthMiddleware } from \"./middlewares/adminAuth\";  // Import admin middleware\r\n\r\nexport function middleware(req: NextRequest) {\r\n    // Apply adminAuthMiddleware to /api/admin/list route\r\n    if (req.url.includes(\"/api/admin/list\")) {\r\n        return adminAuthMiddleware(req);\r\n    }\r\n\r\n    return NextResponse.next();  // Continue processing for other routes\r\n}\r\n\r\n// Define the matcher for specific routes\r\nexport const config = {\r\n    matcher: [\r\n        \"/api/admin/list\",\r\n    ],\r\n};\r\n"],"names":[],"mappings":"AAAA,oBAAoB;;;;;AACpB;AAAA;AACA,gPAAgE,0BAA0B;;;AAEnF,SAAS,WAAW,GAAgB;IACvC,qDAAqD;IACrD,IAAI,IAAI,GAAG,CAAC,QAAQ,CAAC,oBAAoB;QACrC,OAAO,CAAA,GAAA,uIAAA,CAAA,sBAAmB,AAAD,EAAE;IAC/B;IAEA,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI,IAAK,uCAAuC;AACxE;AAGO,MAAM,SAAS;IAClB,SAAS;QACL;KACH;AACL"}}]
}